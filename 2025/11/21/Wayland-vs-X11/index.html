<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="yuziwe" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      Wayland vs X11 
      
      
      |
    
     Yuzi
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-H0T3X6BSRZ"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-H0T3X6BSRZ');
    </script>
  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 8.1.1"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Oranges</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Wayland vs X11</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
          2025-12-07 15:59:01
        </span>
        
      </div>
      <div class="markdown-body">
        <ul>
<li><a target="_blank" rel="noopener" href="https://wayland.freedesktop.org/">Wayland</a></li>
</ul>
<h2 id="Wayland介绍"><a href="#Wayland介绍" class="headerlink" title="Wayland介绍"></a>Wayland介绍</h2><blockquote>
<p>Wayland is a replacement for the X11 window system protocol and architecture with the aim to be easier to develop, extend, and maintain.</p>
</blockquote>
<p>如官网所述，其诞生是为了替换老的X11窗口协议，听起来还不错，所以Wayland也是一个窗口协议喽？。</p>
<blockquote>
<p>Wayland is the language (protocol) that applications can use to talk to a display server in order to make themselves visible and get input from the user (a person). A Wayland server is called a “compositor”. Applications are Wayland clients.</p>
</blockquote>
<p>所有的应用程序表现为Wayland客户端，通过Wayland协议与Wayland服务端通信，由Wayland服务端进行渲染并接收来自用户的输入（鼠标or键盘）反馈给前台应用程序。</p>
<blockquote>
<p>Wayland also refers to a system architecture. <strong>It is not just a server-client relationship between a compositor and applications.</strong> There is no single common Wayland server like Xorg is for X11, but every graphical environment brings with it one of many compositor implementations. Window management and the end user experience are often tied to the compositor rather than swappable components. </p>
</blockquote>
<p>Okay，也不完全是，准确来说是一个架构，统称为Wayland，其并非可以被视为由Wayland客户端、Wayland服务端以及通信的Wayland协议所组成的一般架构。</p>
<p>从描述来看，Wayland并不存在一个普适的服务端，几乎所有的图形环境都自带多种服务端的实现，并不容易被替换，往往取决于图形环境的实现。</p>
<blockquote>
<p>A core part of Wayland architecture is libwayland: an inter-process communication library that translates a protocol definition in XML to a C language API. This library does not implement Wayland, it merely encodes and decodes Wayland messages. The actual implementations are in the various compositor and application toolkit projects.</p>
</blockquote>
<p>这里描述的是一个底层C语言API库，用于将以XML格式包装的协议文件转换为外部可用的API接口，然后由各种应用程序以及Wayland服务器实现具体细节。</p>
<blockquote>
<p>Wayland does not restrict where and how it is used. A Wayland compositor could be a standalone display server running on Linux kernel modesetting and evdev input devices or on many other operating systems, or a nested compositor that itself is an X11 or Wayland application (client). Wayland can even be used in application-internal communication as is done in some web browsers. </p>
</blockquote>
<p>如此看来，Wayland的通信协议用的比较广泛，甚至在一些Web浏览器中被用作进程间通信协议。</p>
<p>这里介绍了三种应用场景：</p>
<ol>
<li><p>单一显示服务器。</p>
<p> 例如通过调用Linux的KMS来管理显示器，使用evdev读取用户输入事件，从而构成了你的桌面环境基础。</p>
</li>
<li><p>嵌套兼容角色。</p>
<p> 例如将其作为X11架构中的客户端角色，或者在一个Wayland合成器中表现为一个Wayland客户端，可以一直嵌套下去，他们之间通过<code>libwayland</code>通信。</p>
</li>
<li><p>进程间通信。</p>
<p> 例如在基于Chrome内核的浏览器中，Wayland被用于浏览器组件之间的通信框架。</p>
</li>
</ol>
<p>看来我们也可以基于<strong>libwayland</strong>开发一些有趣的东西了。</p>
<h2 id="Wayland架构"><a href="#Wayland架构" class="headerlink" title="Wayland架构"></a>Wayland架构</h2><blockquote>
<p>A good way to understand the wayland architecture and how it is different from X is to follow an event from the input device to the point where the change it affects appears on screen.</p>
</blockquote>
<p>Okay，让我们窥探下内部架构及原理。</p>
<p><img src="/2025/11/21/Wayland-vs-X11/x-architecture.png" alt="x-arch"></p>
<blockquote>
<p>The kernel gets an event from an input device and sends it to X through the evdev input driver. The kernel does all the hard work here by driving the device and translating the different device specific event protocols to the linux evdev input event standard.</p>
</blockquote>
<p>Okay，kernel率先通过驱动设备完成了很多硬核工作并提供了统一接口用于<code>X server</code>读取用户输入。</p>
<blockquote>
<p>The X server determines which window the event affects and sends it to the clients that have selected for the event in question on that window. The X server doesn’t actually know how to do this right, since the window location on screen is controlled by the compositor and may be transformed in a number of ways that the X server doesn’t understand (scaled down, rotated, wobbling, etc).</p>
</blockquote>
<p><code>X server</code>收到事件后会识别是哪个窗口的事件，然后将其发送给已经在该窗口订阅该事件的客户端，酷似一个封建大家长hhhh。</p>
<p>现代X11在引入合成器后，一切都变了。</p>
<p>引入合成器的目的是为了实现阴影、动画等一系列操作，<code>X server</code>并不像之前一样将窗口直接输出至屏幕上，而是使用缓冲区控制，交给合成器<strong>合成</strong>。</p>
<blockquote>
<p>The client looks at the event and decides what to do. Often the UI will have to change in response to the event - perhaps a check box was clicked or the pointer entered a button that must be highlighted. Thus the client sends a rendering request back to the X server.</p>
</blockquote>
<p><code>X client</code>收到来自<code>X server</code>的事件后决定应该显示什么，然后发回一个渲染请求给<code>X server</code>。</p>
<blockquote>
<p>When the X server receives the rendering request, it sends it to the driver to let it program the hardware to do the rendering. The X server also calculates the bounding region of the rendering, and sends that to the compositor as a damage event.</p>
</blockquote>
<p><code>X server</code>收到渲染请求后，将其发送给驱动让其做渲染。同时会做一些渲染区域的边界计算并将其作为一个<em>污染</em>事件发给合成器。</p>
<p>Btw，<em>污染</em>事件指示屏幕上有哪些像素区域需要被更新。</p>
<blockquote>
<p>The damage event tells the compositor that something changed in the window and that it has to recomposite the part of the screen where that window is visible. The compositor is responsible for rendering the entire screen contents based on its scenegraph and the contents of the X windows. Yet, it has to go through the X server to render this.</p>
</blockquote>
<p>合成器收到这个<em>污染</em>事件后根据其指示对屏幕内容进行重新组合。</p>
<p>合成器基于自身的场景地图以及来自<code>X windows</code>的内容进行重新渲染，然而实际的渲染还得交给<code>X server</code>来与显卡驱动沟通进行最终绘制。</p>
<blockquote>
<p>The X server receives the rendering requests from the compositor and either copies the compositor back buffer to the front buffer or does a pageflip. In the general case, the X server has to do this step so it can account for overlapping windows, which may require clipping and determine whether or not it can page flip. However, for a compositor, which is always fullscreen, this is another unnecessary context switch.</p>
</blockquote>
<p><code>X server</code>拿到来自合成器的渲染请求后还得自己处理一遍重叠窗口的裁剪计算，判定是否能够进行<strong>页面翻转操作</strong>。</p>
<p>然而合成器本来就合成输出的就是一张全屏图像，不存在任何重叠的情况，因此这里又多余了一步。</p>
<blockquote>
<p>As suggested above, there are a few problems with this approach. The X server doesn’t have the information to decide which window should receive the event, nor can it transform the screen coordinates to window-local coordinates. And even though X has handed responsibility for the final painting of the screen to the compositing manager, X still controls the front buffer and modesetting. Most of the complexity that the X server used to handle is now available in the kernel or self contained libraries (KMS, evdev, mesa, fontconfig, freetype, cairo, Qt, etc). In general, the X server is now just a middle man that introduces an extra step between applications and the compositor and an extra step between the compositor and the hardware. </p>
</blockquote>
<p>Okay，开始批判<code>X server</code>了。</p>
<ol>
<li><p><code>X server</code>无法决定事件该发给哪个窗口，也无法将屏幕坐标转换为窗口坐标。</p>
<p> 因为合成器做了一系列变换操作导致窗口坐标与屏幕完全对不上，<code>X server</code>拥有的旧场景地图根本无法支撑处理用户输入事件，最终决策还得交给合成器来完成。</p>
</li>
<li><p>尽管<code>X server</code>将屏幕的最终绘制权交给了合成器，但是它仍然控制着缓冲区以及内核模式设置，也就是说最终呈现还是<code>X server</code>在做。</p>
<p> 合成器将所有信息整合并输出为一整幅图像，明明掌握着确切的窗口信息以及像素信息，但最终的呈现还得交给<code>X server</code>再处理一遍进行缓冲区的交换或拷贝后再进行显示模式的设置等等操作。</p>
</li>
<li><p>尴尬的是，内核已经提供了<code>X server</code>所具有的一系列<em>复杂</em>的能力，总的来说，<code>X server</code>变成了一个小透明，中间人，在应用程序和合成器之间，在合成器和硬件之间引入了额外操作，造成了不必要的性能及资源损耗。</p>
</li>
</ol>
<blockquote>
<p>In wayland the compositor is the display server. We transfer the control of KMS and evdev to the compositor. The wayland protocol lets the compositor send the input events directly to the clients and lets the client send the damage event directly to the compositor: </p>
</blockquote>
<p><img src="/2025/11/21/Wayland-vs-X11/wayland-architecture.png" alt="wayland-arch"></p>
<p>Wayland将合成器作为背后一把手，将KMS以及evdev的控制权移交给合成器。</p>
<p>合成器将用户输入事件直接交给客户端或应用程序，客户端将<em>污染</em>事件直接返回给合成器进行最终的合成及绘制。</p>
<blockquote>
<p>The kernel gets an event and sends it to the compositor. This is similar to the X case, which is great, since we get to reuse all the input drivers in the kernel.</p>
</blockquote>
<p>合成器会接收来自内核的输入事件。</p>
<blockquote>
<p>The compositor looks through its scenegraph to determine which window should receive the event. The scenegraph corresponds to what’s on screen and the compositor understands the transformations that it may have applied to the elements in the scenegraph. Thus, the compositor can pick the right window and transform the screen coordinates to window-local coordinates, by applying the inverse transformations. The types of transformation that can be applied to a window is only restricted to what the compositor can do, as long as it can compute the inverse transformation for the input events.</p>
</blockquote>
<p>合成器查询它自己记录的场景地图，决定由那个窗口接收事件。</p>
<p>场景地图包含了屏幕上的内容以及坐标变换信息。</p>
<p>合成器选择正确的窗口进行屏幕坐标到窗口坐标的逆变换。</p>
<blockquote>
<p>As in the X case, when the client receives the event, it updates the UI in response. But in the wayland case, the rendering happens in the client, and the client just sends a request to the compositor to indicate the region that was updated.</p>
</blockquote>
<p>在<code>X</code>系统中，客户端接收到输入事件后在响应中更新界面。</p>
<p>在<code>Wayland</code>系统中，由客户端进行缓冲区渲染然后告知合成器那一块区域被更新了。</p>
<blockquote>
<p>The compositor collects damage requests from its clients and then recomposites the screen. The compositor can then directly issue an ioctl to schedule a pageflip with KMS.</p>
</blockquote>
<p>合成器收集来自客户端们的<em>污染</em>事件并重新组合屏幕。然后通过KMS使用<code>ioctl</code>调度<strong>页面翻转</strong>操作。</p>
<h2 id="Wayland-Rendering"><a href="#Wayland-Rendering" class="headerlink" title="Wayland Rendering"></a>Wayland Rendering</h2><blockquote>
<p>One of the details I left out in the above overview is how clients actually render under wayland. By removing the X server from the picture we also removed the mechanism by which X clients typically render. But there’s another mechanism that we’re already using with DRI2 under X: direct rendering. With direct rendering, the client and the server share a video memory buffer. The client links to a rendering library such as OpenGL that knows how to program the hardware and renders directly into the buffer. The compositor in turn can take the buffer and use it as a texture when it composites the desktop. After the initial setup, the client only needs to tell the compositor which buffer to use and when and where it has rendered new content into it. </p>
</blockquote>
<p>Wayland采用<strong>直接渲染</strong>的技术支撑客户端的渲染。</p>
<p>客户端与合成器共享一块video缓冲区，客户端链接的图形库，例如OpenGL知道如何操作这块缓冲区并渲染。</p>
<p>合成器随后将这块缓冲区作为一种<strong>贴图</strong>用于合成窗口，客户端操作这块缓冲区后只需要通知合成器哪块儿缓冲区被使用了以及何时，在缓冲区的哪个位置渲染了新内容以便于后续合成。</p>
<blockquote>
<p>This leaves an application with two ways to update its window contents:</p>
</blockquote>
<p>Okay，两种方式更新窗口内容？</p>
<blockquote>
<p>Render the new content into a new buffer and tell the compositor to use that instead of the old buffer. The application can allocate a new buffer every time it needs to update the window contents or it can keep two (or more) buffers around and cycle between them. The buffer management is entirely under application control.</p>
</blockquote>
<p>由应用程序将新内容写入新分配的缓冲区，然后告诉合成器别用老的缓冲区了，用新的。</p>
<p>新的缓冲区组织方式由应用程序自己控制。</p>
<blockquote>
<p>Render the new content into the buffer that it previously told the compositor to use. While it’s possible to just render directly into the buffer shared with the compositor, this might race with the compositor. What can happen is that repainting the window contents could be interrupted by the compositor repainting the desktop. If the application gets interrupted just after clearing the window but before rendering the contents, the compositor will texture from a blank buffer. The result is that the application window will flicker between a blank window or half-rendered content. The traditional way to avoid this is to render the new content into a back buffer and then copy from there into the compositor surface. The back buffer can be allocated on the fly and just big enough to hold the new content, or the application can keep a buffer around. Again, this is under application control.</p>
</blockquote>
<p>渲染新的内容到先前已告知合成器使用的缓冲区中，即共享缓冲区。</p>
<p>这种方式会与合成器产生竞争冲突，具体表现为应用程序的重绘可能会被合成器的桌面重绘中断。</p>
<p>如果应用程序在清空窗口内容后，但是在渲染新内容之前被中断，那么合成器得到的是一块空白缓冲区，结果就造成了应用窗口在空白界面和半渲染界面之前频繁闪烁。</p>
<p>传统解决该问题的办法是，应用程序将新内容渲染至<strong>后台缓冲区</strong>然后拷贝到合成器表面。</p>
<p>同样，后台缓冲区也需要应用程序自己控制分配和释放。</p>
<blockquote>
<p>In either case, the application must tell the compositor which area of the surface holds new contents. When the application renders directly to the shared buffer, the compositor needs to be noticed that there is new content. But also when exchanging buffers, the compositor doesn’t assume anything changed, and needs a request from the application before it will repaint the desktop. The idea that even if an application passes a new buffer to the compositor, only a small part of the buffer may be different, like a blinking cursor or a spinner. </p>
</blockquote>
<p>应用程序必须告知合成器哪块儿区域被更新为新内容了。</p>
<p>即便在交换缓冲区时，合成器也不会做任何重绘操作，必须收到应用程序的明确更新请求后才会重绘桌面。</p>
<p>这是因为即使交换了一整个缓冲区，但仅仅其中一小部分内容发生改变。</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2025/11/16/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8F%B0%E8%B7%AF%E7%94%B1%E5%99%A8/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
              2025-12-07 15:59:01
            </span>
            
          </div>
          <div class="post-foot-prev">
            
              <a href="/2025/11/23/%E5%88%9D%E6%8E%A2Niri/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Wayland%E4%BB%8B%E7%BB%8D"><span class="toc-text">Wayland介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wayland%E6%9E%B6%E6%9E%84"><span class="toc-text">Wayland架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wayland-Rendering"><span class="toc-text">Wayland Rendering</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        






  <div id="gitalk-container"></div>

  <script>
    function loadGitalkSuc() {
      const gitalk = new Gitalk({
        clientID: 'Ov23limkk0qt1yYBZwZV',
        clientSecret: 'f53b76b89152c9e9b9ccb909f6350c119544383b',
        repo: 'yuziwe.github.io',
        owner: 'yuziwe',
        admin: ['yuziwe'],
        id: location.pathname,
        distractionFreeMode: false
      })

      gitalk.render('gitalk-container')
    }
  </script>
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" onload="loadGitalkSuc(this)"></script>
  



      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/yuziwe">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2025 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="where are you?">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Wayland%20vs%20X11 + '&url=' + https%3A%2F%2Fyuziwe.github.io%2F2025%2F11%2F21%2FWayland-vs-X11%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://yuziwe.github.io/2025/11/21/Wayland-vs-X11/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
